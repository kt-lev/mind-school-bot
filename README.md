# Mind School Telegram Bot

## Що це?

Це проект Telegram чат-боту для навчального центру Mind School. Призначений для автоматизованого менеджменту клієнтів з платформи Telegram, зокрема збір та обробка клієнтських даних, можливість цілодобово реалізовувати перелік послуг, забезпечення цілодобового callback-контакту з клієнтами.

## Як це працює

### Користувацькі функції

Після ініціалізації чату з ботом користувачу надається можливість реалізувати три функції:
- Переглянути перелік послуг
- Задати питання
- Дізнатися інформацію про центр

<img src="img/userfunc/main_menu.gif" alt="Головне меню" width="300"/>

#### Переглянути перелік послуг

Після натискання відповідної клавіші користувачу прийде повідомлення з переліком послуг у вигляді Inline-кнопок. При натисканні на кнопку користувачу відкривається відповідна сторінка сервісу Telegrahp (telegra.ph) з описом послуги. Ці сторінки створюються та редагуються SMM-менеджерами. В цьому документі буде прикріплене посилання на CRM-систему, де користувач може безпосередньо записатися на заняття. Цим забезпечується реалізація та організація клієнт-менеджменту цілодобово та без фактичної участі менеджерів у спілкуванні.

<img src="img/userfunc/services_menu.gif" alt="Меню з переліком послуг, реалізація кнопок та сторінок послуг" width="300"/>

#### Задати питання

Натиснувши кнопку "Задати питання" в користувача запитується ім'я та номер телефону, після чого користувач пише своє питання. Ці питання разом з ім'ям, номером та нікнеймом-користувача надсилаються адміністратору, а також зберігаються в окремому файлі, тому питання можна задати в будь-який час доби та в будь-який день. Відповідь адміністратор може надати в робочий (або ж в зручний для адміна) час. Це забезпечує спілкування в зручний і для користувача, і для менеджера спосіб.

<img src="img/userfunc/ask_question.gif" alt="Реалізація надсилання питання" width="300"/>

#####

<img src="img/code/save_question.png" alt="Збереження питання в JSON форматі" width="300"/>

#### Дізнатися інформацію про центр

Кнопка "Про нас" надсилає повідомлення з коротким описом навчального центру, контактні номери телефону, робочі години, адресу з гіперпосиланням на сторінку закладу у сервісі Google Maps, а також прикріплює карту з вказаною адресою. Це дозволяє зменшити кількість маніпуляцій користувачем для отримання відповідної інформації, а також покращити універсальність для різних систем та сервісів. Крім того, дана інформація зберігається в окремому файлі, що забезпечує необхідну відмовостійкість.

<img src="img/userfunc/about_us.gif" alt="Реалізація кнопки 'Про нас'" width="300"/>

### Функції адміністратора

Адміністратор даного бота має необхідні функції для менеджменту більшої частини його функціоналу. Це забезпечує підвищену гнучкість та адаптивність системи, а також більшу автономність від послуг технічного спеціаліста для виконання задач нетехнічного характеру. Адміністратор в своєму розпорядженні такі інструменти:

- Редагувати послуги
  - Додавати нові послуги
  - Видаляти існуючі послуги
  - Зміна назви чи опису вже існуючих послуг
- Редагувати інформацію з розділу "Про нас"
  - Змінювати опис
  - Змінювати контактні номери телефону
  - Змінювати посилання на сторінку компанії в Google Maps
  - Змінювати посилання на веб-сайт компанії
  - Змінювати вказану адресу

Авторизація в якості адміністратора відбувається через команду /admin.

<img src="img/adminfunc/admin_login.gif" alt="Авторизація адміністратора" width="300"/>

Так як всі робочі комунікації відбуваються з робочого Telegram-аккаунту, то і інструментарій адміністратора доступний лише для робочого аккаунта. Якщо Ви спробуєте авторизуватися не з робочого аккаунту, то доступ Вам не відкриється, натомість прийде наступне повідомлення:

<img src="img/adminfunc/admin_rejected.gif" alt="Помилка авторизація в якості адміністратора" width="300"/>

Дані робочого аккаунту зберігаються в окремому файлі, що забезпечує стійкість до збоїв роботи хоста.

Після авторизації буде ініціалізоване меню Keyboard-кнопок "Редагувати послуги" та "Редагувати 'Про нас'"

<img src="img/adminfunc/result_admin_login.jpg" alt="Меню Keyboard-кнопок після авторизації" width="300">

#### Редагувати послуги

У адміністратора є можливість редагувати послуги, що відображаються клієнту. Він може додавати нові, видаляти та змінювати існуючі послуги. Так як представлення послуг реалізується через меню Inline-кнопок з посиланням на описові сторінки, то об'єктами редагування є назва кнопки та URL-посилання.

Після натискання кнопки "Редагувати послуги" відобразиться перелік Inline-кнопок для зміни існуючих послуг та три Keyboard-кнопки: "Додати послугу", "Видалити послугу" та "Повернутися".

<img src="img/adminfunc/edit_service.gif" alt="Перелік послуг для редагування" width="300"/>

##### Редагування існуючих послуг

Після відображення меню з переліком послуг для редагування Ви можете обрати яку саме ви хочете змінити натисканням на відповідну кнопку. Далі у Вас відобразиться повідомлення з уточненням вибраної послуги та двома Inline-кнопками: "Змінити назву" та "Змінити опис"

<img src="img/adminfunc/choose_service_to_edit.gif" alt="Вибір послуги" width="300"/>

Далі натисканням на відповідну кнопку Ви можете змінити те, що хочете. Після натискання бот попросить Вас ввести в залежності від Вашого вибору або нову назву, або URL-посилання на описову сторінку.

<img src="img/adminfunc/rename_service.gif" alt="Зміна назви" width="300"/>

#####

 <img src="img/adminfunc/edit_result.jpg" alt="Результат зміни назви" width="300"/>

#####

<img src="img/adminfunc/rewrite_service.gif" alt="Зміна URL-посилання на описову сторінку" width="300"/>

##### Додавання нових послуг та видалення існуючих послуг

Щоб додати нову послугу Ви маєте натиснути відповідну кнопку. Далі у Вас запитає назву та URL-посилання на описову сторінку. Після цього прийде повідомлення з уточненням яку саме послугу Ви додали.

<img src="img/adminfunc/add_service.gif" alt="Додавання нових послуг" width="300"/>

#####

<img src="img/adminfunc/add_result.jpg" alt="Результат додавання" width="300"/>

Видалення існуючих функцій відбувається ще простіше, так як для цього треба натиснути відповідну кнопку та ввести назву послуги яку хочете видалити.

<img src="img/adminfunc/delete_service.gif" alt="Видалення існуючих послуг" width="300"/>

#####

<img src="img/adminfunc/delete_result.jpg" alt="Результат видалення" width="300"/>

#### Редагувати інформацію з розділу "Про нас"

Ще однією можливістю адміністратора є зміна інформації з розділу "Про нас". Адмін може змінювати всі дані що надсилаються при відповідному запиті користувача, але адмін не може змінити будову подачі інформації. Щоб редагувати інформацію з розділу "Про нас" необхідно натиснути відповідну кнопку, після чого висвітиться меню Inline-кнопок з переліком даних, які Ви можете змінити.

Обравши необхідне поле бот попросить Вас ввести нов

у інформацію. Поля нічим не обмежені, тож зміни Ви можете вносити будь-які. Вони зберігатимуться в окремому файлі, тому вся система є повністю відмовостійкою.

<img src="img/adminfunc/before_edit_about_us.jpg" alt="Дані до редагування" width="300"/>

#####

<img src="img/adminfunc/edit_about_us.gif" alt="Приклад редагування даних" width="300"/>

#####

<img src="img/adminfunc/after_edit_about_us.jpg" alt="Результат редагування даних" width="300"/>

## Технічні питання
### Основна інформація
Даний проєкт повністю написаний на мові Python версії 3.12.0. Код працює асинхронно, а також із записом/читанням основних даних в/з окремих файлів JSON-формату, що забезпечує необхідну відмовостікість при помилках роботи хоста. Він був написаний з використанням наступних бібліотек:

- Стандартні бібліотеки:
  - os - для роботи з оперативною системою та середовищем 
  - asyncio - для асинхронної роботи коду, з метою забезпечити планомірну роботу прогарми
  - datetime - для роботи з часом в програмі
  - json - для роботи з файлами JSON-формату
- Нестанадртні бібліотеки:
  - aiogram (v.3.10.0) та всі приналежні до неї бібліотеки (aiohttp, aiofiles, magic-filters, urllib.3, yarl і т.д.) - основна структурна бібліотека кода, призначена для написання API Telegram Bot.
  - pytz (v.2024.1) - бібліотека для роботи з часовими поясами


Програма реалізована в трьох файлах: [main.py](app/main.py), [admin_handler.py](app/admin_handler.py) та [user_handler.py](app/user_handler.py).
Основний файл - main.py. admin_handler.py та user_handler.py - файли обробників запитів.

Чотири допоміжні файли формату JSON для збереження даних: 
- [about_us.json](json/about_us.json) - для збереження інформації про нас
- [admins.json](json/admins.json) - для збереження даних аккаунта, що має права адміністратора
- [services.json](json/services.json) - для збереження даних про наявні послгуи
- [questions.json](json/questions.json) - для збереження запитань (тексту запитання, імені та номеру що вів користувач, час коли надіслали питання та нікнейм користувача)

#### Основний файл (main.py)

Файл main.py хоч і є основним файлом, фактично виконує функцію конектора. В ньому оголошено об'єкт класу Bot та присвоюєно API токен.

<img src="img/code/bot_creating.png" alt="Створення об'єкта типу Bot" width="300"/>

API токен для HTTP запитів буде заданий як змінна середовища та звідти присвоєний в змінну коду, що забезпечує необхідну безпеку.

<img src="img/code/api_token_from_env.png" alt="Отримання API токена в код" width="300"/>

Також в цьому файлі оголошено обробник, тобто об'єкт типу Dispatcher.

<img src="img/code/dispatcher_creating.png" alt="Створення об'єкта типу Dispatcher" width="300"/>

Також тут створена функція 'main()', в якій виконується дві речі:
1. Запускається полінг бота.
2. Підключаються два роутери до відповідних файлів.

<img src="img/code/main_func.png" alt="Функція main()" width="300"/>

З додаткового тут присутня ще функція для перевірки існування файлу та зчитування даних з нього, а також тут оголошуються та зберігаються усі глобальні змінні, що використовуються в програмі.

#### Файли обробників запитів ([admin_handler.py](app/admin_handler.py) та [user_handler.py](app/user_handler.py))

Ці файли опрацьовують команди, дій та повідомлення користувача. Файл [admin_handler.py](app/admin_handler.py) опрацьовує [функції адміністратора](#функції-адміністратора), а файл [user_handler.py](app/user_handler.py) опрацьовує [користувацькі функції](#користувацькі-функції). Для забезпечення цілісності даних доступ до функцій адміністратора надається після перевірки.

#### Особливі технічні рішення

##### Функція перевірки існування файлу та читання з нього

Для забезпечення необхідної відмовостійкості для безперебійної роботи програми необхідно забезпечити стабільну роботу з файлами, так як шанс помилки під час роботи із зовнішніми структурами вищий ніж всередині самої програми. [Файли обробників](#файли-обробників-запитів-admin_handlerpy-та-user_handlerpy) підключаються та конфігуруються за допомогою окремого об'єкту класа з бібліотеки aiogram, то робота з файлами формату JSON необхідно конфігурувати самостійно.
У всій програмі робота з файлами JSON відбувається наступним чином:
1. Зчитування даних з файлу та запис їх в окрему змінну
2. Робота з цїєю змінною (додавання, редагування чи видалення об'єктів та їх полів)
3. Відредаговану змінну перезаписуємо у той же файл
Такий формат роботи дозволяє уникати зайвих помилок та особливо повторень. Але якщо програма не знаходить файл для зчитування даних, або ж по якійсь причині не може зчитати файл, то ми отримаємо помилку та відповідно порушення усієї роботи програми.
Для уникнення цього була написана проста функція перевірки існування та доступності файлу. Принцип роботи функції:

<img src="img/code/schemas/schema_of_check_file.png" alt="Принцип роботи функції перевірки існування та доступності файлу" width="400"/>

Спочатку за заданим шляхом перевіряється існування файлу. Якщо такого файлу немає, то ініціалізується пустий список, якщо ж такий файл існує, то воно намагається викачати дані з файлу у змінну. Далі якщо ж під час викачування отримана помилка json.JSONDecodeError, тобто неможливість викачати дані, то знову ж таки ініціалізується пустий список. Далі в залежності від того чи пустий в нас список, чи ні, ми або заповнюємо його та записуємо, де під час запису за відсутності необхіжного файлу він створюється автоматично, або перезаповнюємо існуючі записи та записуємо в існуючі файли.
Реалізація цієї функції дуже проста:

<img src="img/code/check_file.png" alt="Код функції перевірки існування та доступності файлу" width="600"/>

##### Робота зі станами для відокремлення розгорнутих текстових повідомлень

Даний бот працює як і з командами, так і з keyboard-кнопками що надсилають фіксований текст, так і з довільним текстом що вводить користувач самостійно. Якщо для перших двух використовуються "магічні"-фільтри що захоплюють конкретні повідомлення, то для останнього такий підхід не спрацює. Для цього я використовую Finite State Machine (далі - FSM) в який записуються стани користувача відповідно до того що він робить. 

<img src="img/code/FSM_example.png" alt="Приклад використання ініціалізацію стану" width="500"/>

До того ж FSM використовується для збереження деяких даних. Обробник що захоплює всі текстові повідомлення отримавши повідомлення перевіряє наявність стану, і в залежності від стану обробляє ці дані або ж зберігає у відповідне поле об'єкту станів.

<img src="img/code/FSM_classes.png" alt="Клас станів" width="500"/>

#

<img src="img/code/writing_in_field.png" alt="Запис тексту у поле класу" width="500"/>

Наприклад, за допомогою станів користувач може задати питання адміну, ось принцип роботи:

<img src="img/code/schemas/schema_to_state.png" alt="Принцип надсилання запитань на основі збереження станів" width="500"/>

Коли користувач натискає кнопку "Задати питання" користувачу надходить повідмолення "Введіть ім'я:" і разом з цим в об'єкт state встановлюється стан 'waiting_for_name'. Далі обробник текстових повідомлень виявивши що поле 'state' має стан 'waiting_for_name' запише текст цього повідомлення в поле 'name' цього ж об'єкта. Далі надішле повідомлення "Введіть номер:", змінить стан 'state' на 'waiting_for_number' і так само обробить номер після надислання, записавши в поле 'number'. Далі так само з текстом запитання, але тоді вже буде записуватися не в 'state', а в словник 'person', в який також будуть перенесені збережені в об'єкт дані. Словник 'person' буде дозаписано в список 'data', який в свою чергу буде записаний в файл 'questions.json'.
Ось як воно реалызовано в коді:

<img src="img/code/sending_question_code.png" alt="Код надсилання запитань на основі збереження станів" width="700"/>